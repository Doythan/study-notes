# 디자인 패턴 (Design Pattern)

### 디자인 패턴 ?

: 과거 소프트웨어 개발 과정에서 발견한 설계 노하우를 패턴으로 정리한 것

* 코드가 비슷해서 의사소통 하는데 장점이 있음
* 검증된 구조이므로 설계를 빠르게 할 수 있음&#x20;

#### 디자인 패턴 유형

* 생성 (Creational) 패턴 : 객체 인스턴스 생성에 관여, 클래스 정의와 객체 생성 방식을 구조화, 캡슐화를 수행하는 패턴
* 구조 (Structural) 패턴 : 더 큰 구조 형성 목적으로 클래스나 객체의 조합을 다루는 패턴
* 행위 (Behavioral) 패턴 : 클래스나 객체들이 상호 작용하는 방법과 역할 분담을 다루는 패턴

#### 생성패턴 \[생빌 프로 팩앱싱]

* Builder : 복잡한 인스턴스를 조립하여 만드는 구조로, 복합 객체를 생성할 때 **객체를 생성하는 방법과 객체를 구현하는 방법을 분리함**으로써 동일한 생성 절차에서 서로 다른 표현 결과를 만들 수 있음
* Prototype : 처음부터 일반적인 **원형**을 만들어 놓고, 그것을 복사한 후 필요한 부분만 수정하여 사용함.
* Factory Method : **상위 클래스에서 객체를 생성하는 인터페이스를 정의**하고, **하위 클래스에서 인스턴스를 생성**하도록 하는 방식으로, 상위 클래스에서는 인스턴스를 만드는 방법만 결정하고, 하위 클래스에서 그 데이터의 생성을 책임지고 조작하는 함수들을 오버라이딩하여 인터페이스와 실제 객체를 생성하는 클래스를 분리할 수 있는 특성을 가짐.
* Abstract Factory(=Kit) : 구체적인 클래스에 의존하지 않고 **서로 연관되거나 의존적인 객체들의 조합을 만드는 인터페이스를 제공**하고, 패턴을 통해 생성된 클래스에서는 사용자에게 인터페이스(API)를 제공하고, 구체적인 구현은 Concrete Product 클래스에서 이루어짐
* Singleton : **전역 변수를 사용하지 않고** 객체를 하나만 생성하도록 하며, 생성된 객체를 어디에서든지 참조할 수 있도록 함.

#### 구조패턴 \[구 브데 퍼플 프록 컴 어]

* Bridge : **기능의 클래스 계층과 구현의 클래스 계층을 연결**하고, 구현부에서 추상 계층을 분리하여 추상화된 부분과 실제 구현 부분을 독립적으로 확장할 수 있는 디자인 패턴&#x20;
* Decorator : **기존의 구현되어 있는 클래스에 필요한 기능을 추가**해 나가는 설계 패턴 기능 확장이 필요할 때 객체 간의 결합을 통해 기능을 동적으로 유연하게 확장할 수 있게 해주어 상속의 대안으로 사용함
* Facade : **복잡한 시스템에 대하여 단순한 인터페이스를 제공**함으로써 사용자와 시스템 간 또는 여타 시스템과의 **결합도를 낮추**어 시스템 구조에 대한 파악을 쉽게 하는 패턴 오류에 대해서 단위별로 확인할 수 잇게 하며, 사용자 측면에서 단순한 인터페이스 제공을 통해 접근성을 높일 수 있음 **통합된 인터페이스** **제공**
* Flyweight : 다수의 객체로 생성될 경우 **모두가 갖는 본질적인 요소를 클래스화하여 공유**함으로써 **메모리를 절약**하고, '**클래스 경량화**'를 목적으로 함 여러개의 '가상 인스턴스'를 제공하여 메모리 절감&#x20;
* Proxy : 실체 객체에 대한 **대리 객체**로 실체 객체에 대한 접근 이전에 필요한 행동을 취할 수 있게 만들며, 이 점을 이용해서 미리 할당하지 않아도 상관없는 것들을 실제 이용할 때 할당하게 하여 메모리 용량을 아낄 수 있으며, 실체 객체를 드러나지 않게 하여 **정보 은닉**의 역할도 수행함&#x20;
* Composite : 객체들의 관계를 **트리 구조**로 구성하여 부분-전체 계층을 표현함 사용자가 단일 객체와 복합 객체 모두 동일하게 다루도록 하는 패턴&#x20;
* Adapter : 기존에 생성된 클래스를 **재사용할 수 있도록 중간에서 맞춰주는 역할을 하는 인터페이스를 만드**는 패턴으로, **상속을 이용하는 클래스 패턴과 위임을 이용하는 인스턴스 패턴의 두 가지 형태**로 사용됨.&#x20;

#### 행위패턴 \[행 미인이 템옵 스테비커 스트 메체]

* Mediator : 객체 지향 설계에서 객체의 수가 너무 많아지면 서로 간 통신을 위해 복잡해져서 객체 지향에서 가장 중요한 느슨한 결합의 특성을 해칠 가능성이 있으므로 중간에 이를 통제하고 지시할 수 있는 역할을 하는 **중재자**를 두고, **중재자에게 모든 것을 요구하여 통신의 빈도수를 줄여** 객체 지향의 목푤를 달성하게 해줌.
* Interpreter : 언어의 다양한 **해석**, 구체적으로 구문을 나누고 그 분리된 구문의 해석을 맡는 클래스를 각각 작성하여 여러 형태의 언어 구문을 해석할 수 있게 만듬. **문법 자체를 캡슐화**하여 사용&#x20;
* Iterator : 컬렉션 내부구조를 노출하지 않고, 그 집합체 안에 들어있는 모든 요소를 **순차적으로 탐색**할 수 있고 즉, 복잡 객체의 원소를 순차적으로 접근 가능하게 해줌.&#x20;
* Template Method : 어떤 작업을 처리하는 일부분을 **서브 클래스로 캡슐화**해 전체 일을 수행하는 구조는 바꾸지 않으면서 **특정 단계에서 수행하는 내역을 바꿈**.&#x20;
* Observer : 한 객체의 상태가 바뀌면 그 객체에 의존하는 **다른 객체들한테 연락**이 가고 **자동으로 내용이 갱신**되고, **일대 다**의 의존성을 가지며 상호 작용하는 객체 사이에서는 가능하면 느슨하게 결합하는 디자인 패턴.
* State : **객체 상태를 캡슐화하여 클래스화**함으로써 그것을 참조하게 하는 방식으로 상태에 따라 다르게 처리할 수 있도록 **행위 내용을 변경**하여, 변경 시 **원시 코드의 수정을 최소화**할 수 있고, **유지보수의 편의성**도 갖는 디자인 패턴 객체의 상태에 따라 행위 내용을 변경&#x20;
* Visitor : 각 클래스 데이터 구조로부터 처리 기능을 분리하여 별도의 클래스를 만들어 놓고, 해당 **클래스의 메서드가 각 클래스를 돌아다니며 특정 작업을 수행**하도록 만들고, **객체의 구조는 변경하지 않으**면서 **새로운 기능(연산)만 따로 추가하거나 확장**할 때 사용하는 디자인 패턴&#x20;
* Command : 실행될 기능을 캡슐화함으로써 **주어진 여러 기능을 실행할 수 있는 재사용성이 높은 클래스를 설계**하는 패턴 하나의 추상 클래스에 메서드를 만들어 각 **명령**이 들어오면 그에 맞는 **서브 클래스가 선택되어 실행되는 특징**을 갖는 디자인 패턴 **요구사항을 객체로 캡슐화**&#x20;
* Strategy : **알고리즘 군을 정의**하고(추상 클래스) 같은 알고리즘을 각각 하나의 클래스로 캡슐화한 다음, 필요할 때 서로 교환해서 사용할 수 있게 함.&#x20;
* Memento : 클래스 설계 관점에서 **객체의 정보를 저장**할 필요가 있을 때 적용 **Undo** 기능을 개발할 때 사용
* Chain of Responsibility : 정적으로 어떤 기능에 대한 처리의 연결이 하드코딩 되어 있을 때 기능 처리의 연결 변경이 불가능하지만, 이를 동**적으로 연결되어 있는 경우에 따라 다르게 처리될 수 있도록 연결**한 디자인 패턴 **한 요청을 2개 이상의 객체에서 처리**&#x20;
